---
import Header from '../components/Header.astro';
import SidebarElement from '../components/SidebarElement.jsx';
import '../styles/global.css';
// No frontmatter needed for static layout
import { supabase } from '../lib/client-supabase.js';

const notename = "{notename}" 
---
<meta charset="UTF-8" />
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<body>
<div class="notes-page-wrapper">
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css"
/>
<Header/>
<div class="notes-root">
  <SidebarElement client:load onNoteSelect={null} selectedNoteId={null} />
  <main class="obsidian-main">
    <div class="obsidian-topbar">Welcome.md</div>
    <textarea
      id="editor"
      class="obsidian-editor"
      data-placeholder="Start writing in Markdown..."
    >
# Welcome to Your Notes

## Modes
- **INSERT mode**: (default) You can type and edit your note. Status bar shows `--INSERT--`.
  - Press `ESC` to switch to NORMAL mode.
- **NORMAL mode**: (like Vim) Typing is disabled, only navigation and commands work. Status bar shows `--NORMAL--`.
  - Press `ESC` again to return to INSERT mode.
  - In NORMAL mode, type `:` to enter command mode.

## Console Commands (type in command mode)
  - `:new {notename}` — Create a new note with the given title (must use curly braces)
  - `:w` or `:write` — Save the current note
  - `:q` or `:quit` — (placeholder) Quit
  - `:wq` — Save and quit (placeholder)
  - `:help` — Show this help message

## Shortcuts
  - `Ctrl+l` — New note
  - `Ctrl+S` — Save note
  - `Ctrl+Delete` — Delete current note
  - `Ctrl+O` — Open note (placeholder)
  - `Ctrl+F` — Find in note (placeholder)
  - `Ctrl+B` — Bold
  - `Ctrl+I` — Italic
  - `Ctrl+K` — Insert link

---

This is a placeholder for your Obsidian-style notes app.

- Use the sidebar to browse notes
- The main area is your Markdown editor
- Add features like linking, tags, and search as you go!
    </textarea>
  </main>
  
</div>
<div id="status-bar" class="status-bar">notes.md 1 line --INSERT--</div>
</div>
</body>

<script>
  // Mode state (INSERT or NORMAL)
  let currentMode = 'INSERT';
  let commandMode = false;
  let currentNoteTitle = 'Untitled'; // Track current note title

  // Listen for note selection events from SidebarElement
  window.addEventListener('noteSelected', ((event: CustomEvent) => {
    const note = event.detail;
    selectNote(note);
  }) as EventListener);

  // Keyboard shortcuts
  document.addEventListener('keydown', async (event) => {
    // Handle command mode input
    if (commandMode) {
      handleCommandInput(event);
      return;
    }
    
    // ESC: Toggle between INSERT and NORMAL mode
    if (event.key === 'Escape') {
      event.preventDefault();
      toggleMode();
    }
    
    // In NORMAL mode, check for ':' to enter command mode
    if (currentMode === 'NORMAL' && event.key === ':') {
      event.preventDefault();
      enterCommandMode();
      return;
    }
    
    // In NORMAL mode, prevent typing in editor (except for specific shortcuts)
    if (currentMode === 'NORMAL') {
      const editor = document.getElementById('editor') as HTMLTextAreaElement;
      if (editor && document.activeElement === editor) {
        // Allow only specific keys in NORMAL mode
        const allowedKeys = ['Escape', ':', 'Control', 'Meta', 'Alt', 'Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End', 'PageUp', 'PageDown'];
        if (!allowedKeys.includes(event.key) && !event.ctrlKey && !event.metaKey && !event.altKey) {
          event.preventDefault();
          return;
        }
      }
    }
    
    // Ctrl+N: New note
    if (event.ctrlKey && event.key === 'l') {
      event.preventDefault();
      createNewNote();
    }
    
    // Ctrl+S: Save note
    if (event.ctrlKey && event.key === 's') {
      event.preventDefault();
      saveCurrentNote();
    }
    
    // Ctrl+Delete: Delete current note
    if (event.ctrlKey && event.key === 'm') {
      event.preventDefault();
      deleteCurrentNote();
    }
    
    // Ctrl+O: Open note (placeholder)
    if (event.ctrlKey && event.key === 'o') {
      event.preventDefault();
      openNoteDialog();
    }
    
    // Ctrl+F: Find in note
    if (event.ctrlKey && event.key === 'f') {
      event.preventDefault();
      focusFindInNote();
    }
    
    // Ctrl+B: Bold
    if (event.ctrlKey && event.key === 'b') {
      event.preventDefault();
      insertMarkdown('**', '**');
    }
    
    // Ctrl+I: Italic
    if (event.ctrlKey && event.key === 'i') {
      event.preventDefault();
      insertMarkdown('*', '*');
    }
    
    // Ctrl+K: Link
    if (event.ctrlKey && event.key === 'k') {
      event.preventDefault();
      insertMarkdown('[', '](url)');
    }
  });

  // Toggle between INSERT and NORMAL mode
  function toggleMode() {
    currentMode = currentMode === 'INSERT' ? 'NORMAL' : 'INSERT';
    commandMode = false; // Exit command mode when switching
    updateStatusBar();
    
    // Optional: Change editor behavior based on mode
    const editor = document.getElementById('editor') as HTMLTextAreaElement;
    if (editor) {
      if (currentMode === 'NORMAL') {
        editor.blur(); // Remove focus in NORMAL mode
      } else {
        editor.focus(); // Restore focus in INSERT mode
      }
    }
  }

  // Enter command mode
  function enterCommandMode() {
    commandMode = true;
    const statusBar = document.getElementById('status-bar');
    if (statusBar) {
      // Create input field
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'command-input';
      input.placeholder = 'Enter command...';
      input.value = ':';
      
      // Clear status bar and add input
      statusBar.innerHTML = '';
      statusBar.appendChild(input);
      input.focus();
      input.select();
    }
  }

  // Handle command input
  function handleCommandInput(event: KeyboardEvent) {
    const input = document.querySelector('.command-input') as HTMLInputElement;
    if (!input) return;

    if (event.key === 'Escape') {
      // Exit command mode
      exitCommandMode();
    } else if (event.key === 'Enter') {
      // Execute command
      const command = input.value.substring(1); // Remove the ':'
      executeCommand(command);
      exitCommandMode();
    }
  }

  // Exit command mode
  function exitCommandMode() {
    commandMode = false;
    updateStatusBar();
  }

  // Execute command
  function executeCommand(command: string) {
    const cmd = command.trim().toLowerCase();

    // :up {int} command
    if (cmd.startsWith('up ')) {
      const match = command.match(/^up\s+(-?\d+)$/i);
      if (match) {
        const n = parseInt(match[1], 10);
        moveCursorUp(n);
        return;
      } else {
        console.log('Usage: :up {int}');
        return;
      }
    }

    // :down {int} command
    if (cmd.startsWith('down ')) {
      const match = command.match(/^down\s+(-?\d+)$/i);
      if (match) {
        const n = parseInt(match[1], 10);
        moveCursorUp(-n); // Use negative n to move down
        return;
      } else {
        console.log('Usage: :down {int}');
        return;
      }
    }

    // :{int} command (go to line)
    if (/^\d+$/.test(cmd)) {
      const lineNum = parseInt(cmd, 10);
      moveCursorToLine(lineNum);
      return;
    }

    // Handle :new {notename} command with curly braces
    if (cmd.startsWith('new ')) {
      // Match :new {notename}
      const match = command.match(/^new\s+\{(.+)\}$/i);
      if (match && match[1].trim()) {
        const noteName = match[1].trim();
        createNewNoteWithTitle(noteName);
        return;
      } else {
        console.log('Usage: :new {notename}');
        return;
      }
    }

    // Handle :cd {notename} command with curly braces
    if (cmd.startsWith('cd ')) {
      // Match :cd {notename}
      const match = command.match(/^cd\s+\{(.+)\}$/i);
      if (match && match[1].trim()) {
        const noteName = match[1].trim().toLowerCase();
        // Try to find the note in the sidebar's notes list
        const sidebar = document.querySelector('.obsidian-notes-list');
        if (sidebar) {
          const noteItems = Array.from(sidebar.querySelectorAll('.obsidian-note-item'));
          let found = false;
          for (const item of noteItems) {
            const titleSpan = item.querySelector('.note-title');
            if (titleSpan && titleSpan.textContent && titleSpan.textContent.trim().toLowerCase() === noteName) {
              (item as HTMLElement).click();
              found = true;
              break;
            }
          }
          if (!found) {
            alert(`Note not found: ${match[1].trim()}`);
          }
        } else {
          alert('Sidebar not found.');
        }
        return;
      } else {
        alert('Usage: :cd {notename}');
        return;
      }
    }

    switch (cmd) {
      case 'q':
      case 'quit':
        // Could implement quit functionality
        console.log('Quit command');
        break;
      case 'w':
      case 'write':
        saveCurrentNote();
        break;
      case 'wq':
        saveCurrentNote();
        // Could implement quit after save
        break;
      case 'help':
        alert('Available commands: new {notename}, up {int}, down {int}, {int}, q(uit), w(rite), wq, help');
        break;
      case "d":
        deleteCurrentNote();
      default:
        console.log(`Unknown command: ${command}`);
    }
  }

  // Move cursor up/down by n lines (negative n = down)
  function moveCursorUp(n: number) {
    const editor = document.getElementById('editor') as HTMLTextAreaElement;
    if (!editor) return;
    
    const value = editor.value;
    const lines = value.split('\n');
    const currentPos = editor.selectionStart;
    
    // Find current line and column
    let currentLine = 0;
    let currentCol = 0;
    let charCount = 0;
    
    for (let i = 0; i < lines.length; i++) {
      const lineLength = lines[i].length;
      if (currentPos >= charCount && currentPos <= charCount + lineLength) {
        currentLine = i;
        currentCol = currentPos - charCount;
        break;
      }
      charCount += lineLength + 1;
    }
    
    // Calculate target line
    let targetLine = currentLine - n;
    if (targetLine < 0) targetLine = 0;
    if (targetLine >= lines.length) targetLine = lines.length - 1;
    
    // Calculate target position
    let targetPos = 0;
    for (let i = 0; i < targetLine; i++) {
      targetPos += lines[i].length + 1;
    }
    
    // Add column offset (clamped to line length)
    const targetCol = Math.min(currentCol, lines[targetLine].length);
    targetPos += targetCol;
    
    editor.selectionStart = editor.selectionEnd = targetPos;
    editor.focus();
  }

  // Move cursor to a specific line number (1-based)
  function moveCursorToLine(lineNum: number) {
    const editor = document.getElementById('editor') as HTMLTextAreaElement;
    if (!editor) return;
    
    const value = editor.value;
    const lines = value.split('\n');
    
    // Convert to 0-based index and clamp to valid range
    const targetLine = Math.max(0, Math.min(lineNum - 1, lines.length - 1));
    
    // Calculate position at the start of the target line
    let targetPos = 0;
    for (let i = 0; i < targetLine; i++) {
      targetPos += lines[i].length + 1;
    }
    
    editor.selectionStart = editor.selectionEnd = targetPos;
    editor.focus();
  }

  // Create new note with custom title
  function createNewNoteWithTitle(title: string) {
    // Dispatch custom event with the title - don't click the button
    window.dispatchEvent(new CustomEvent('createNoteWithTitle', { detail: { title } }));
  }

  // Helper functions for shortcuts
  function createNewNote() {
    // This will be handled by the SidebarElement component
    const newNoteBtn = document.querySelector('.new-note-btn') as HTMLButtonElement;
    if (newNoteBtn) {
      newNoteBtn.click();
    }
  }

  function selectNote(note: any) {
    // Update current note title
    currentNoteTitle = note.title || 'Welcome Guide';
    
    // Update topbar
    const topbar = document.querySelector('.obsidian-topbar');
    if (topbar) {
      topbar.textContent = currentNoteTitle;
    }
    
    // Load note content into editor
    const editor = document.getElementById('editor') as HTMLTextAreaElement;
    if (editor) {
      editor.value = note.content || '';
      editor.focus();
    }
    
    updateStatusBar();
  }

  function saveCurrentNote() {
    const editor = document.getElementById('editor') as HTMLTextAreaElement;
    const selectedNote = document.querySelector('.obsidian-note-item.selected');
    
    if (editor && selectedNote) {
      const content = editor.value;
      const title = selectedNote.textContent || 'Untitled';
      
      // Save to backend
      saveNoteToBackend(title, content);
      
      // Show save indicator
      showSaveIndicator();
    }
  }

  function saveNoteToBackend(title: string, content: string) {
    // Get user info first
    fetch('/api/auth/user-data')
      .then(res => res.json())
      .then(data => {
        const user = data.user;
        if (!user || !user.id) {
          console.error('No user data available');
          return;
        }
        
        // Now save with user included
        return fetch('/api/auth/notes', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ user, title, content }),
        });
      })
      .then(response => {
        if (response && !response.ok) {
          throw new Error('Save failed');
        }
      })
      .catch(error => {
        console.error('Failed to save note:', error);
      });
  }

  function showSaveIndicator() {
    const statusBar = document.getElementById('status-bar');
    if (statusBar) {
      const originalText = statusBar.textContent;
      statusBar.textContent = originalText?.replace('--INSERT--', '--SAVED--') || '';
      setTimeout(() => {
        statusBar.textContent = originalText || '';
      }, 1000);
    }
  }

  function openNoteDialog() {
    alert('Open note dialog - implement file picker here');
  }

  function focusFindInNote() {
    alert('Find in note - implement search within current note');
  }

  function insertMarkdown(prefix: string, suffix: string) {
    const editor = document.getElementById('editor') as HTMLTextAreaElement;
    if (!editor) return;
    
    const start = editor.selectionStart;
    const end = editor.selectionEnd;
    const selectedText = editor.value.substring(start, end);
    
    const newText = prefix + selectedText + suffix;
    editor.value = editor.value.substring(0, start) + newText + editor.value.substring(end);
    
    // Set cursor position
    editor.selectionStart = start + prefix.length;
    editor.selectionEnd = end + prefix.length;
    editor.focus();
  }

  async function saveNoteContent() {
    const editor = document.getElementById('editor') as HTMLTextAreaElement;
    if (!editor) return;
    
    try {
      const res1 = await fetch(`api/auth/user-data`);
      if (!res1.ok) {
        console.error('Failed to get user data:', res1.status);
        return;
      }
      
      const data = await res1.json();
      const user = data.user;
      console.log('User data:', user);
      
      if (!user || !user.id) {
        console.error('No user data available');
        return;
      }
      
      const content = editor.value;
      console.log('Saving note:', { title: currentNoteTitle, contentLength: content.length });
      
      // Use the tracked current note title instead of looking for selected note
      const saveResponse = await fetch('/api/auth/notes', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ user: user, title: currentNoteTitle, content: content }),
      });
      
      if (!saveResponse.ok) {
        const errorData = await saveResponse.json();
        console.error('Save failed:', errorData);
        return;
      }
      
      const saveResult = await saveResponse.json();
      console.log('Save successful:', saveResult);
      
    } catch (error) {
      console.error('Error saving note:', error);
    }
  }

  // Update status bar
  function updateStatusBar() {
    const editor = document.getElementById('editor') as HTMLTextAreaElement;
    const statusBar = document.getElementById('status-bar');
    
    if (editor) {
      const lines = editor.value.split('\n');
      for (let i = lines.length; i--; i > -1) {
        if (lines[i] != "") {
          break;
        } else {
          lines.splice(i, 1);
        }
      }
      const linesLength = lines.length;
      
      if (statusBar) {
        statusBar.textContent = `${currentNoteTitle}  ${linesLength} lines  --${currentMode}--`;
      }
    }
  }

  function deleteCurrentNote() {
    
    const selectedNote = document.querySelector('.obsidian-note-item.selected');
    console.log(selectedNote);
    if (selectedNote) {
      // Trigger the delete button click on the selected note
      const deleteBtn = selectedNote.querySelector('.delete-note-btn') as HTMLButtonElement;
      if (deleteBtn) {
        deleteBtn.click();
      }
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const editor = document.getElementById('editor') as HTMLTextAreaElement;
    editor?.addEventListener('input', () => {
      updateStatusBar();
      saveNoteContent();
    });
    updateStatusBar();
  });
</script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap');
@import '../styles/SidebarElement.css';
</style>

<style>
.notes-page-wrapper {
  min-height: 100vh;
  background: #f6f8fa;
}
.notes-root {
  display: flex;
  height: calc(100vh - var(--header-height, 3em));
  width: 100vw;
  background: #f8f2e4;
  background-color: #f8f2e4;
  position: relative;
  top: 0;
}
.obsidian-sidebar {
  width: 15.5rem;
  background: #f8f2e4;
  border-right: 1px solid #e6e1d7;
  display: flex;
  flex-direction: column;
  padding: 0;
  height: 100%;
}
.obsidian-sidebar-header {
  padding: 1.2rem 1rem 1rem 1rem;
  font-size: 1.1rem;
  font-weight: bold;
  border-bottom: 1px solid rgb(var(--gray));
  letter-spacing: 1px;
  color: rgb(var(--black));
  background: #f8f2e4;
}
.obsidian-notes-list {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem 0;
  background: #f8f2e4;
}
.obsidian-note-item {
  padding: 0.5rem 1rem;
  cursor: pointer;
  border-radius: 0;
  margin: 0;
  color: #666;
  transition: none;
  background: #f8f2e4;
  border-bottom: 1px solid #e6e1d7;
}
.obsidian-note-item.selected {
  background: #f8f2e4;
  color: #333;
  font-weight: bold;
}
.obsidian-note-item:hover {
  background: #f8f2e4;
  color: #333;
}
.obsidian-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #f8f2e4;
  height: 100%;
}
.obsidian-topbar {
  height: 48px;
  background: #f8f2e4;
  border-bottom: 1px solid rgb(var(--gray));
  display: flex;
  align-items: center;
  padding: 0.8rem 1.5rem 3rem 1.5rem;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: 1px;
  color: rgb(var(--black));
  font-family: 'Inter', sans-serif;
}

.obsidian-editor {
  flex: 1;
  padding: 2rem 2.5rem;
  background: #f8f2e4;
  color: rgb(var(--black));
  font-size: 1.1rem;
  border: none;
  outline: none;
  resize: none;
  width: 100%;
  height: 100%;
  border-radius: 8px;
  box-sizing: border-box;
  font-family: 'Atkinson Hyperlegible', Arial, sans-serif;
}

#status-bar {
  position: fixed;
  bottom: 0;
  height: 2rem;
  left: 15.5rem;
  width: 100%;
  background: #f8f2e4;
  color: #3a363698;
  padding: 4px 12px;
  font-family: monospace;
  font-size: 14px;
  z-index: 20; /* ensure it's above other elements */
}

@media (max-width: 800px) {
  .obsidian-sidebar {
    width: 60px;
  }
  .obsidian-sidebar-header {
    display: none;
  }
  .obsidian-note-item {
    padding: 0.7rem 0.5rem;
    font-size: 0.95rem;
  }
  .obsidian-main {
    padding: 0;
  }
  .obsidian-editor {
    padding: 1rem 0.5rem;
  }
}

.status-bar {
  width: 100%;
  background: #f8f2e4;
  color: #666;
  font-family: 'Fira Mono', 'Consolas', 'Menlo', monospace;
  font-size: 1rem;
  padding: 0.2rem 1rem 0.2rem 1rem;
  border-radius: 0;
  border-top: 1px solid #e6e1d7;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  letter-spacing: 0.03em;
  box-sizing: border-box;
  margin-top: 0;
}

.command-input {
  background: transparent;
  border: none;
  outline: none;
  color: #444;
  font-family: 'Fira Mono', 'Consolas', 'Menlo', monospace;
  font-size: 1rem;
  width: 100%;
  letter-spacing: 0.03em;
  padding: 0;
  margin: 0;
}

.command-input::placeholder {
  color: #666;
}
</style>