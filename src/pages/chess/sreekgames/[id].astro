---
import WebsiteLayout from '../../../layouts/WebsiteLayout.astro';
import PgnPlayer from '../../../components/PgnPlayer.jsx';
import { supabase } from '../../../lib/supabase.js';
import { Chess } from 'chess.js';

export const prerender = false;

const { id } = Astro.params;

let game = null;
let error = null;

try {
  const { data, error: fetchError } = await supabase
    .from('sreekgames')
    .select('id, pgn, "White", "Black"')
    .eq('id', id)
    .single();
  if (fetchError) {
    error = fetchError.message || 'Game not found';
  } else {
    game = data;
  }
} catch (e: any) {
  error = e?.message || 'Unknown error';
}

if (error || !game) {
  return Astro.redirect('/404');
}

// Parse PGN to extract game info for embeds
function parseHeaders(pgn: string): Record<string, string> {
  const headers: Record<string, string> = {};
  const headerRegex = /^\[(\w+)\s+"([^"]*)"\]$/gm;
  let m: RegExpExecArray | null;
  while ((m = headerRegex.exec(pgn)) !== null) {
    headers[m[1]] = m[2];
  }
  return headers;
}

function stripHeaders(pgn: string): string {
  return pgn.replace(/^\[[^\]]*\]\s*$/gm, '').trim();
}

function getFinalPosition(pgn: string): string {
  try {
    // Remove headers first
    let body = stripHeaders(pgn || '');
    
    // Clean up the body: remove variations, comments, NAGs, newlines
    body = body
      .replace(/\([^)]*\)/g, '') // Remove variations
      .replace(/\{[^}]*\}/g, '') // Remove comments
      .replace(/\$\d+/g, '') // Remove NAGs
      .replace(/\r?\n/g, ' ') // Remove newlines
      .replace(/\s+/g, ' ') // Normalize whitespace
      .replace(/\s*(1-0|0-1|1\/2-1\/2|\*)\s*$/, '') // Remove result
      .trim();
    
    // Extract all moves more carefully
    const moves: string[] = [];
    // Match move numbers and moves (more permissive pattern)
    const tokens = body.split(/\s+/);
    
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i].trim();
      if (!token) continue;
      
      // Skip move numbers like "1." or "1..."
      if (/^\d+\.(\.\.)?$/.test(token)) {
        continue;
      }
      
      // Skip result markers
      if (/^(1-0|0-1|1\/2-1\/2|\*)$/.test(token)) {
        break;
      }
      
      // This should be a move - extract SAN (everything before any non-alphanumeric ending)
      // Handle moves like "e4!", "e4?", "Nf3+", "Qxf7#", "O-O", "O-O-O"
      const moveMatch = token.match(/^([a-zA-Z0-9+\-x#=!?]+)/);
      if (moveMatch && moveMatch[1]) {
        const san = moveMatch[1].replace(/[!?]+$/, ''); // Remove annotation marks
        if (san && san.length > 0 && san !== '1-0' && san !== '0-1' && san !== '1/2-1/2') {
          moves.push(san);
        }
      }
    }
    
    // Play through all moves
    const chess = new Chess();
    chess.reset();
    
    for (const san of moves) {
      try {
        // Try making the move
        const move = chess.move(san, { strict: false } as any);
        if (!move) {
          // If move fails, try with sloppy mode via different options
          try {
            chess.move(san);
          } catch {
            // If still fails, log but continue
            console.warn(`Failed to parse move: ${san}`);
            break;
          }
        }
      } catch (e) {
        // If move completely fails, we've likely reached an invalid position
        // Return the last valid position
        console.warn(`Error playing move ${san}:`, e);
        break;
      }
    }
    
    return chess.fen();
  } catch (e) {
    console.error('Error in getFinalPosition:', e);
    return 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
  }
}

const headers = parseHeaders(game.pgn || '');
const finalFen = getFinalPosition(game.pgn || '');
const event = headers['Event'] || 'Chess Game';
const result = headers['Result'] || '';
const date = headers['Date'] || '';
const site = headers['Site'] || '';
const gameTitle = `${game.White} vs ${game.Black}${result ? ` (${result})` : ''}`;
const gameDescription = `${event}${date ? ` • ${date}` : ''}${site ? ` • ${site}` : ''}` || `Chess game between ${game.White} and ${game.Black}`;

// Use our own API endpoint to serve board images (better for Discord embeds)
const boardImageUrl = new URL(`/api/chess-board-image?fen=${encodeURIComponent(finalFen)}`, Astro.url.origin).href;
const pageUrl = new URL(Astro.url.pathname, Astro.url.origin).href;
const baseUrl = Astro.url.origin;
---

<WebsiteLayout>
  <Fragment slot="head">
    <!-- Primary Meta Tags -->
    <title>{gameTitle} - Annotated Chess Game</title>
    <meta name="title" content={gameTitle} />
    <meta name="description" content={gameDescription} />
    
    <!-- Open Graph / Facebook / Discord -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content={pageUrl} />
    <meta property="og:title" content={gameTitle} />
    <meta property="og:description" content={gameDescription} />
    <meta property="og:image" content={boardImageUrl} />
    <meta property="og:image:secure_url" content={boardImageUrl} />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="400" />
    <meta property="og:image:height" content="400" />
    <meta property="og:site_name" content="Agora Chess" />
    
    <!-- Twitter / Discord -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content={pageUrl} />
    <meta name="twitter:title" content={gameTitle} />
    <meta name="twitter:description" content={gameDescription} />
    <meta name="twitter:image" content={boardImageUrl} />
    <meta name="twitter:image:src" content={boardImageUrl} />
  </Fragment>
  
  <div style="display: flex; flex-direction: column; gap: 1rem;">
    <a href="/chess/sreekgames" style="text-decoration: none; color: #0070f3">← Back to games</a>
    <h1>{game.White} vs {game.Black}</h1>
    <div style="margin-top: 1rem;">
      <PgnPlayer client:load pgn={game.pgn} gameId={game.id} />
    </div>
  </div>
</WebsiteLayout>


